# -*- coding: utf-8 -*-
"""python basic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X7P3U38DwQhmsfsyc_ry60WtX-f9ECFJ

# welcome to learn python

# print function
"""

# anything inside the double quotes that will be printed as a output
print("hello world")
print("12343")
print("!@$#$%^&**((())()(")

"""# comment lines

single comment line
"""

# print("hello world")

"""mtliple line comment"""

# '''print("hello world")
# print("12343")
# print("!@$#$%^&**((())()(")'''


# print("hello world")
# print("12343")
# print("!@$#$%^&**((())()(")

"""'''  ''' is not working in colab

This is a commentwritten inmore than just one line

# Variables
"""

x = 10

x = "welcome"

# asign same value to multiple variables
x = y = z = 1
print(x)
print(y)
print(z)

"""**multiple** **variable**"""

x, y, z = [1,2,3]
x, y, z = 1,2,3
x, y, z = (1,2,3)

x = 2
y = 3
z = x + y
s = z
print("Sum of x + y is: ", z)

# unique id(memory reference) of a variable
a = 50
#print id(a)
s1 = 257
s2 = 257

print (id(s1))
print (id(s2))

"""# Local Variable"""

g = "hello"

#Local Variable
def bob():
    global l
    l = "local"
    print(l)

def foo():
    return "hello"
    print(a)

print (foo())
a = foo()
print(a)
# print(me)   # Asking for a global variable

"""global variable"""

# Global variable
def bob():
    global me
    me = "locally defined"   # Defined locally but declared as global
    print(me)

bob()
print(me) # Asking for a global variable

# Refer to global variable if not found locally
s = "I love New York!!!"

def f(): 
    print(s) # try to find in global scope
    
s = "I love Paris in the summer!!!" #global scope

f()

#  Can't use variable locally before defining it
def f(): 
    print(s) # Error
    s = "I love London!"

s = "I love Paris!" 
f()
print(s)

"""# Data Types
Text Type: 	str

Numeric Types: 	int, float, complex

Sequence Types: 	list, tuple, range

Mapping Type: 	dict

Set Types: 	set, frozenset

Boolean Type: 	bool

Binary Types: 	bytes, bytearray, memoryview
"""

# text 
x = "string"
print("text : ",x)

# numeric data type
x = 10
y = 10.0
z = 10j
print("int = ",x,"float = ",y,"complex = ",z)

"""# List"""

# Sequence type
x = ["apple", "banana", "cherry"] 
print(x)

# index start from 0 to n
x[0]

x[1]

x[2]

# while exceeding the index value it givse error
x[3]

"""# Data types

Integer
"""

a = 5
print(a, "is of type", type(a))

"""float"""

a = 2.0
print(a, "is of type", type(a))

"""complex"""

a = 1+2j
print(a, "is complex number?", isinstance(1+2j,complex))

"""str"""

a = "Grey Atom"
print(a, "is of type", type(a))

"""bool"""

a = True
print(a, "is of type", type(a))

a = [1, 2, 3, 4, "hello", ["a", "b"], True, False]
#print(a, "is of type", type(a))

a = None
b = None 
print(a)

"""Dictionary"""

a = {"institute" : "Grey Atom", "course" : "Data Science"}
print(a, "is of type", type(a))

"""List"""

#a = ("Peter", "Male", 26)
#print(a, "is of type", type(a))

l = [1,2,3,4]
m = l

#l = l.append(5)

m.append(6)

print(l,type(l))
print(m,type(m))

print ("Total Money in My Pocket: ", 10*5 + 5*100)

print("2 to the power 4 is : ", 2 ** 4);

print("Power can also be calculated with pow(): ", pow(2, 4))

print ("Is it true that 2 is less than 3? ", 2 == 3)

print("Remainder of 5 divided by 2: ", 5%2)

num1= 5
num2 =10

sum  = num1+num2
print (sum)

# Rounding a float value
print("rounding a float value : ", round(2.8));

('rounding a float value : ', 3.0)

# Absolute value
print("absolute value of -2 is : ", abs(-2))

import math
print (type(math))

print (math.sqrt(12))
print (math.floor(2.5))

"""# STRING"""

str1 = 'single quotes'
print(str1)

str2 = "double quotes"
print(str2)

print ('The newline \n will not expand')

# Character can be accessed by index
string = "hello world"
print (string[0])

# Concatenation
string = "hello world"
string = string + ' Goodbye, world';
print(string)

# Repeat words
string = "hello world "
print(string*2)

"""# *SUBSTRING*"""

# Substrings

string = "Hello world again and again"
string[10:-23]

print (string[6:11]) # "world"
print (string[:5])   # "Hello"
print (string[22:])  # "again"
print (string[-7:-2])# "d aga"

"""# LIST"""

marks = [20, 50, 30, 80, 75,  65]

list_of_different_objects = ["Peter", 1000, 10.5]

list_of_lists = [marks, list_of_different_objects, ['red','green','blue']]

# Empty list
empty_list = []
empty_list.append(1) # add 1 to list
empty_list.append(2) # add 2 to list
empty_list.append(3) # add 3 to list
print (empty_list)

# list indexing
x = [1,2,3,4,5]
x[0]

# Access from last value
x[-1]

# List element can be accessed by index position like in string
marks = [20, 50, 30, 80, 75,  65]
print (marks[0])  # 20
print (marks[2])  # 30
print (marks[-1]) # index from last
print (marks[-4]) # index from last

# Nested list
nested_list = [1,2,3,[4,5,['target']]]
print (nested_list[3])
print (nested_list[3][2])

colors = ['RED', 'GREEN', 'BLUE', 'YELLOW']
print (colors[1:-1])        # ['RED', 'YELLOW']

colors[0:2] = ["PURPLE"]    # replace ['RED', 'GREEN'] with ['PURPLE']
print (colors)

colors = ['RED', 'GREEN', 'BLUE', 'YELLOW']
# The for-in statement makes it easy to loop over the items in a list
for item in colors:
        print (item)

# If you need both the index and the item, use the enumerate function
for index, item in enumerate(colors):
    print(index, item)

# Uncommon way - If you need only the index, use range and len
for index in range(len(colors)):
    print(index)

# The list object supports the iterator protocol
itr = iter(colors)
print(itr.__next__()) # fetch first value
print(itr.__next__() )# fetch second value

# Sum & Length
marks = [20, 50, 30, 80, 75,  65]

print (sum(marks))
print (len(marks))

# append element at end
colors = ['RED', 'GREEN', 'BLUE', 'YELLOW']
colors.append('PURPLE')
print (colors)

# insert at given index
colors = ['RED', 'GREEN', 'BLUE', 'YELLOW']
colors.insert(1,'PURPLE')
print (colors)

# Extend - adds the elements in list2 to the end of the list1.
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1.extend(list2)
print (list1)

# Extend using +
level = ["beginner", "intermediate", "advanced"]
other_words = ["novice", "expert"]
print (level + other_words)

# Index of an element
colors = ['RED', 'GREEN', 'BLUE', 'YELLOW']
print (colors.index('BLUE'))

# Remove list element
num = [1, 2, 3, 4]
num.remove(2)
print (num)

# use del to remove
num = [1, 2, 3, 4]
del num[1]
print (num)

# Sort in ascending order
num = [5, 2, 4, 3]
num.sort()
print (num)

# Reverse list
letters = ['A', 'B', 'C', 'D']
letters.reverse()
print (letters)

# pop a value
num = [10, 20, 30, 40]
x = num.pop(2)
print (x)
y = num.pop()
print (y)

# check for pallindrome
list = ['a', 'b', 'c', 'b', 'a']
print (list == list[::-1])

# Remove duplicate from list
t = [1, 2, 3, 1, 2, 5, 6, 7, 8]
s = []
for i in t:
       if i not in s:
          s.append(i)
        
print (s)

#Median
list = [13, 23, 11, 16, 15, 10, 26]
list.sort()
print (list)
length = len(list)
print ('Median is: ', list[int(length/2)])

# Generational Comprehension
l = []
for i in range(10):
    l.append(i*i)

d = {"a":1 , "b":2, "c":1 }

l = [(k, d[k]) for k in d]
print (l)

# List Comprehension - Cross product of two sets
colours = ["red", "green", "yellow"]
things = ["house", "car", "tree" ]
coloured_things = [ (x,y) for x in colours for y in things ]
print (coloured_things)

# Convert Celsius to Fahrenheit 
Celsius = [39.2, 36.5, 37.3, 37.8]
Fahrenheit = [ ((float(9)/5)*x + 32) for x in Celsius ]
print (Fahrenheit)

"""# Dict
Python's efficient key/value hash table structure is called a "dict".
"""

## dict[key] = value-for-that-key
institute = {}
institute['name'] = 'Grey Atom'
institute['course'] = 'Data Science'
institute['duration'] = '3 Months'
print (institute)

print (institute['name'])
print (institute['course'])
print (institute['duration'])

# Iterating over a dict iterates over its keys.
d = {'r': 'red', 'g': 'green', 'b': 'blue', 'c': 'cyan'}
#for key in d: print (key) #for key in dict.keys(): print key

['c', 'r', 'b', 'g']
{3: 'red', 4: 'blue', 5: 'green'}

"""# Set
A set is an unordered collection of items. Every element is unique (no duplicates) and must be immutable.
"""

# set of integers
s = {1, 2, 3, 2, 3}
print(s)

# Set of different data types
s = {1.0, "Hello world", (1, 2, 3)}
print (s)

# Empty set
s = set([1,2,3, 1])

if "a" in {"a": 1}:
    print (True)
else:
    print (False)
    
l = [3, 3, 2, 4, 2, 10]
print (set(l))

set([2, 3, 4, 10])

# find unique elements
l = [1,2,3,2,1,5,6,5,5,5]
unique = set()
for x in l:
    if x not in unique:
          unique.add(x)
print (unique)

# Set of odd number up to 20
a = {x for x in range(20) if x % 2 != 0}
print (a)

# Other methods
my_set = {1, 3, 4, 5, 6}
print(my_set)

# discard an element
my_set.discard(4)
print(my_set)

# remove an element
my_set.remove(6)
print(my_set)

"""# Set Operations"""

# UNION
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
print (A|B)
print (A.union(B))

# INTERSECTION
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
print (A & B)
print (A.intersection(B))

# DIFFERENCE
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
print (A - B)
print (A.difference(B))



# SYMMETRIC DIFFERENCE
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
print (A ^ B)
print (A.symmetric_difference(B))

"""# Tuple
A tuple is similar to a list. Tuples are immutable arrays of arbitrary elements. The elements of a tuple cannot be changed once it is assigned whereas in a list, elements can be changed.
"""

t = (1, 2.5, 3, "Hello World")
print (t)
t[1] = 8 # immutable
print (t)

# lists to tuples and tuples to lists - zip
# The zip function in python accepts a number of sequences (such as lists or arrays) and returns a list of tuples

a = range(0,5)
b = range(5,10)
c = range(10,15)
sequence_of_tuples = zip(a, b, c)
print(sequence_of_tuples)

# zip () in conjuction with * operator can be used to unzip a list
a1,b1,c1 = zip(*sequence_of_tuples)
print(a1)
print(b1)
print(c1)

# *tuple means "treat this tuple as positional arguments to this function call."
def foo(x,y):
    print(x,y)

t = (1,2)
foo(*t)

# **dict means "treat the key-value pairs in the dictionary as additional named arguments to this function call."
def foo(x,y):
    print(x,y)

d = {'x':1, 'y':2}
foo(**d)

# Function signature
def foo(*x):
    print(x)

foo(1,2)

# Function signature
def foo(**d):
    print(d)
foo(x=1, y=2)

# Accessing Elements in a Tuple
my_tuple = ['p','e','r','m','i','t']

print(my_tuple[0])
print(my_tuple[5])
print(my_tuple[-2]) # from right

# Slicing
my_tuple = ('p','r','o','g','r','a','m','i','z')

# elements 2nd to 4th
# Output: ('r', 'o', 'g')
print(my_tuple[1:4])

# elements beginning to 2nd
# Output: ('p', 'r')
print(my_tuple[:-7])

# elements 8th to end
# Output: ('i', 'z')
print(my_tuple[7:])

# elements beginning to end
# Output: ('p', 'r', 'o', 'g', 'r', 'a', 'm', 'i', 'z')
print(my_tuple[:])

# Deleting a Tuple
t = (1, 2.5, 3, "Hello World")
print (t)
del (t)
print (t)

# Iterating through a Tuple
#t = (1, 2.5, 3, "Hello World")
#for value in t:
#    print (value)

l = [1,2,3]
l[2] = 4
print (l)

# Immutable object
x = 3 # int data type
y = x # y is pointing to x

y = 5 # change y, x should not changed - immutable

print (x)
print (y)

# Mutable object
list1 = [1,2,3,4,5] # A list
list2 = list1       # list2 is pointing to the same memory location as list 1
list2.append(8)     # if list2 is changed, list1 will also change - mutable

print (list1)
print (list2)

# inefficient code
container = ["A","B","C","D","E"]
string_build = ""
for data in container:
    string_build += str(data)

string_build

# More efficient
"".join(container)

# Copying a list
colours1 = ["red", "green"]
colours2 = colours1
colours2[1] = "blue"
colours1

# Copy with the Slice Operator
colours1 = ["red", "green"]
colours2 = colours1[:]
colours2[1] = "blue"
print (colours1)
print (colours2)

# Copy with the extend Operator
colours1 = ["red", "green"]
colours2= []
colours2.extend(colours1)
colours2[1] = "blue"
print (colours1)
print (colours2)

# Copy with the list Operator
colours1 = ["red", "green"]
colours2 = colours1
colours2[1] = "blue"
print (colours1)
print (colours2)

# Copy with the copy Operator
import copy
colours1 = ["red", "green"]
colours2= copy.copy(colours1)
colours2[1] = "blue"
print (colours1)
print (colours2)

# Deep copy
import copy

list_a = [[3, 4], [5, 6, [7, 8]]]
list_b = copy.deepcopy(list_a)

list_a[0][1] = 9 # change the first list, second list shoud not change

#print (list_a)
#print (list_b)

l = [1, 2, 3, 4, ["a", "b", "c"]]
m = copy.copy(l)

m.append(5)

l[4].append("d")

print (m)

[1, 2, 3, 4, ['a', 'b', 'c', 'd'], 5]

# Convert Celsius to Fahrenheit
# Formula: ((float(9)/5)*x + 32)

Celsius = [39.2, 36.5, 37.3, 37.8]
Fahrenheit = [ ((float(9)/5)*x + 32) for x in Celsius ]
print (Fahrenheit)

# Find out whether a list is a palindrome

list = ['a', 'b', 'c', 'b', 'a']
print (list == list[::-1])

# Remove duplicate from the below list

t = [1, 2, 3, 1, 2, 5, 6, 7, 8]
s = []
for i in t:
       if i not in s:
          s.append(i)
print (s)

# Given this nest dictionary grab the word "hello".

d = {' k1':[1,2,3, {' tricky' :[' oh' ,' man' ,' inception' , {' target':[1,2,3,' hello']}]}]}
d[' k1'][3][' tricky'][3][' target'][3]

a = range(10)
a

